\documentclass{article}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{titling}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{float}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\title{\Huge System Management \vspace{1cm}}
\author{Riccardo Biella, Elia Perrone, Nicolas Sala, Kevin Dominguez}
\date{Semestre primaverile 2019}
\setcounter{page}{0}
\pagestyle{fancy}
\fancyhf{}

\fancyfoot[C]{Page \thepage \hspace{1pt} of \pageref{LastPage}}


\begin{document}
\maketitle
\thispagestyle{empty}
\pagebreak

\tableofcontents
\lstset{language=C++}
\pagebreak

\section{Esercitazione 01}

\begin{figure}[H]
    \center
    \includegraphics[scale=0.3]{images/schemaRete.png}
    \caption{Schema di rete base}\label{fig:1}
\end{figure}

\subsection{Specifiche del server utilizzato (Gateway GW2000h-GW170hq F1)}
Il server utilizzato per le esercitazioni può contenere fino a quattro nodi, con le seguenti caratteristiche:
\begin{figure}[H]
    \center
    \includegraphics[scale=0.37]{images/specificheServer.png}
\end{figure}

\subsection{Hardware utilizzato}
Ad ogni gruppo è stata assegnata la gestione di un nodo all'interno del rack, esso dispone di un disco rigido, un SSD ed una periferica USB mediante il quale sarà possibile installare un hypervisor sul server.

\subsection{Interfaccia di gestione}
L'interfaccia di management del server, permette la gestione di numerosi aspetti della macchina, tra cui il controllo remoto, che utilizzaremo per lavorare sul server senza essere fisicamente presenti in laboratorio.
L'interfaccia di gestione è raggiungibile all'indirizzo IP: 10.19.0.106, a seguito di una connessione tramite client vpn, con le credenziali seguenti: \\  \textbf{username:} grp6 \\ \textbf{password:} System3m.Man\_grp6
\begin{figure}[H]
    \center
    \includegraphics[scale=0.37]{images/GUIManagement.png}
\end{figure}

\subsection{OpenVPN}
\subsubsection{Obiettivo}
Connettersi tramite OpenVPN ed esplorare l’interfaccia di gestione del proprio
server (10.19.0.101-112) (user: root password: superuser) e documentare
azioni e informazioni disponibili.
(Gli account OpenVPN sono gestiti dal docente, che distribuisce ad ogni gruppo
un certificato personalizzato da importare nel proprio OpenVPN client – esempio
di nome di un certificato: SystemManagement-udp-1194-grp5.ovpn e
SystemManagement-udp-1194-grp5.p12).

\subsubsection{Installazione OpenVPN - Ubuntu x64}
\begin{enumerate}
    \item apt-get install openvpn \\ 
    Installiamo openvpn sulla nostra macchina
    \item openvpn --version \\
    Verifichiamo che l'installazione sia andata a buon fine
    \item openvpn --config client.ovpn \\
    Ci posizioniamo nella cartella (unzippata) che abbiamo scaricato da ICorsi,
    avviamo il client con il certificato corretto (.ovpn) che ci è stato fornito.
\end{enumerate}

\subsubsection{Problematiche} 
    Il server mette a disposizione una finestra con la quale è possibile lavorare in modalità
    grafica stile desktop remoto. Tale applicazione fa scaricare un file .JNLP dal server
    (lanciando il controllo remoto dalla console di gestione). Qualora il certificato di
    sicurezza fosse scaduto, si dovrà procedere a creare il trust al server nella macchina
    client (che altrimenti ne blocca l’esecuzione): aggiungere l’IP del server nelle Exception
    Site List di Java. Utilizzando OpenJDK non è possibile sfruttare l'interfaccia grafica di gestione, per questo 
    motivo abbiamo dovuto installare Oracle JRE.

\subsection{VMware ESXi}
\subsubsection{Descrizione}
VMware ESX Server è un prodotto per la virtualizzazione di livello enterprise offerto da VMware Inc., sussidiaria di Dell Technologies e ancor prima una divisione di EMC Corporation. ESX Server è un componente di un'offerta VMware più grande, VMware Infrastructure, che aggiunge servizi di amministrazione e di affidabilità al prodotto base. 
\subsubsection{Architettura}
Il server ESX include un microkernel che si interfaccia direttamente con la macchina. Nelle versioni ESX 3 e precedenti all'avvio viene lanciato un kernel Linux (una versione modificata di Red Hat Enterprise Linux) che analizza l'hardware della macchina e alcuni componenti di gestione, per poi cedere il controllo al componente vmkernel sviluppato di VMware. Questo è un microkernel con tre interfacce verso l'esterno:
\begin{enumerate}
    \item hardware
    \item sistema guest
    \item servizio console (servizio di gestione delle macchine virtuale che gira sul kernel che ha fatto partire vmkernel)
\end{enumerate}

\subsubsection{Installazione di VMWare} 
    Dopo esserci collegati all'interfaccia di gestione della macchina, sulla scheda Remot Control abbiamo scaricato il file .JNLP ed attraverso la sua esecuzione
    abbiamo installato l'hypervisor: abbiamo settato un IP statico pubblico in modo da non dover
    accedere ogni volta tramite VPN. Abbiamo utilizzato per installare VMWare una periferica USB collegata direttamente al server.
    
\subsubsection{Altre opzioni di virtualizzazione}
\begin{enumerate}
    \item VirtualBox (Linux/Mac/Windows)
    \item Parallels (Linux/Mac/Windows)
    \item QEMU (Linux)
    \item Windows Virtual PC (Windows)
\end{enumerate}

\section{Esercitazione 02}

\begin{figure}[H]
    \center
    \includegraphics[scale=0.3]{images/s2.png}
    \caption{Schema di rete base}\label{fig:1}
\end{figure}

\subsection{Obiettivo e definizione di una struttura di rete}

\begin{figure}[H]
    \center
    \includegraphics[scale=0.5]{images/lavagna.png}
    \caption{Struttura di rete}\label{fig:1}
\end{figure}

\noindent 
L'obiettivo finale dell'esercitazione è quello di virtualizzare l'intera rete collegata alle interfacce LAN e WAN del server.
Nell' immagine è possibile osservare lo schema di rete che vogliamo realizzare.
Nella parte superiore "Phisical", troviamo il server, con le sue interfacce MAN, LAN e WAN.
Nella parte inferiore "Virtual" definiamo l'infrastruttura di rete che vogliamo virtualizzare. Si osservano due virtual switch, collegati a due
port group, allo stato attuale disponiamo solo di un VS e di un PG, perciò dovremo creare un nuovo VS
collegato all'interfaccia LAN e creare un nuovo port group nuovo collegato al VS creato.
I port group non sono altro che un'astrazione ad un livello più alto degli switch,
su di essi possono risiedere le VLAN.
Nel corso dell'esercitazione procederemo ad installare alcune macchine virtuali client e server e un un firewall che sarà collegato ai port group con due interfacce, una LAN e una WAN (pubblica).
Le macchine virtualizzate saranno poi collegate al nostro nuovo port group. L'indirizzo IP assegnato al nostro firewall
finisce in .236. Sul firewall installeremo poi un client VPN.
Come ultimo passaggio dobbiamo spostare l’interfaccia di gestione di ESXi all’interno della rete (LAN).

% Sulla scheda virtual machine dell'interfaccia pubblica del server abbiamo cliccato su Create / Register VM
% per uplodare un'immagine di una nuova macchina virtuale.
\subsection{Rete LAN}
\begin{figure}[H]
    \center
    \includegraphics[scale=0.52]{images/lan.png}
    \caption{Configurazione di rete LAN}\label{fig:1}
\end{figure}
\vspace{0.7 cm}
\subsection{Rete WAN}
\begin{figure}[H]
    \center
    \includegraphics[scale=0.52]{images/wan.png}
    \caption{Configurazione di rete WAN}\label{fig:1}
\end{figure}
\subsection{Firewall utilizzato}
PFSense è una distribuzione software open source basata su FreeBSD adatta per essere utilizzata come firewall/router. 
Ha lo scopo di fornire un firewall potente, sicuro e completamente configurabile utilizzando l'hardware di un comune PC. Nel cuore del sistema c'è FreeBSD e il firewall PF (Packet Filter) in prestito da OpenBSD da cui deriva appunto il suo nome, che ha il significato di "dare maggior senso per l'utente finale a PF".


\subsubsection{Versione utilizzata e requisiti minimi di sistema}
\textbf{Versione:} PFSense \\
\textbf{Memoria RAM:} 512 MB

\subsubsection{Funzionalità}
Possiede le funzionalità basilari di un firewall di qualità:

\begin{itemize}
    \item Stateful Firewall con controllo granulare e possibilità di funzionare in maniera trasparente al layer 2 (in bridging)
    \item Network address translation
    \item HA (High Availability): grazie a CARP permette di configurare due firewall su due macchine identiche per replicarsi e autosostituirsi nel caso di guasto di una delle due (il software pfsync si occupa di replicare lo stato firewall, la tabella delle connessioni e le regole del firewall, permettendo di passare al secondo firewall senza che le connessioni attive di rete cadano)
    \item Load Balancing: bilanciamento del carico di lavoro tra due o più server che si trovano dietro a pfSense (utilizzato normalmente per web server, mail server, ecc.)
    \item VPN server, su protocolli IPsec, OpenVPN e PPTP.
    \item PPPoE server
    \item Grafici RRD ed informazioni sullo stato in tempo reale.
    \item Captive portal
    \item Gestione uPnP e DNS dinamici
\end{itemize}
Grazie all'aggiunta di ulteriori moduli è possibile estendere le funzionalità di base ed integrarne di evolute come web proxying (con Squid), url filtering (Squidguard, DansGuardian), IDS (Snort) , antivirus (HAVP) ed altre ancora, fino alla gestione di messaggistica VoIP con FreeSWITCH. 

\subsection{Installazione Windows Server 2012}
\subsubsection{Versione utilizzata e requisiti minimi di sistema}
\textbf{Versione:} Windows Server 2012 Standard Evaluation\\
\textbf{Memoria RAM:} 2 GB \\
\textbf{Hard Disk:} 60 GB

\subsubsection{Tabella comparativa delle versioni}
\begin{figure}[H]
    \center
    \includegraphics[scale=0.3]{images/tabecomp.png}
    \caption{Versioni Windows Server 2012}\label{fig:1}
\end{figure}

\subsection{Configurazione dei servizi}
\begin{itemize}
    \item \textbf{Active Directory: } Attraverso l'active directory abbiamo creato gli utenti del sistema e dei gruppi per l'assegnamento dei permessi (a livello di sistema operativo). Abbiamo poi creato cartelle per i profili utente sul disco C e aggiunto questi ultimi all'active directory.
    \item \textbf{Domain Controller: } Abbiamo creato il dominio korn.forest nel quale abbiamo inserito i vari client.
    \item \textbf{DHCP: } Abbiamo settato il server come DHCP, è stato necessario impostare l'ip range per gli indirizzi da distribuire, un default gateway e un default dns che corrisponde al server stesso. Inoltre è necessario ricordarsi di disabilitarlo dal firewall.
    \item \textbf{DNS: } Abbiamo creato un DNS associato al dominio appena creato. Nel nostro caso il DNS si occupa di eseguire un semplice forward, non introduce altre regole.
\end{itemize}
\subsection{Installazione di un sistema Windows 10}
\subsubsection{Versione utilizzata e requisiti minimi di sistema}
\textbf{Versione:} Windows 10 Home\\
\textbf{Memoria RAM:} 2 GB \\
\textbf{Hard Disk:} 60 GB

\subsection{Installazione di un sistema Linux}
\subsubsection{Versione utilizzata e requisiti minimi di sistema}
\textbf{Versione:} Kali Linux (con gnome) \\
\textbf{Memoria RAM:} 2048 MB \\
\textbf{Hard Disk:} 20 GB

\subsection{Impostazione avvio automatico}
Attraverso il menù actions delle VM abbiamo abilitato il riavvio automatico nel caso che il server fisico venga
riavviato.
\section{Esercitazione 03}
\subsection{Creazione di una nuova macchina WinClient\_02}
Abbiamo rinominato la macchina MS Windows client in WinClient\_01, e dopo aver copiato la macchina WinClient\_01, l'abbiamo clonato creando un nuovo client WinClient\_02.

\subsection{Creazione di nuovi gruppi utente}
Abbiamo creato nuovi gruppi utente, come segue:
\begin{itemize}
    \item UsrGroup\_A (usr01, usr02)
    \item UsrGroup\_B (usr01, usr02, usr03)
    \item UsrGroup\_C (usr04, UsrGroup\_A)
\end{itemize}
Utilizzando i client descritti in precedenza abbiamo verificato il funzionamento dei profili utenti appena creati.
\subsection{Installazione di un sistema di backup}
\textcolor{red}{MANCA QUESTO PUNTO DELL'ESERCITAZIONE 3}.
\section{Esercitazione 04}
\begin{figure}[H]
    \center
    \includegraphics[scale=0.45]{images/es4.png}
    \caption{Configurazione di rete}\label{fig:1}
\end{figure}
L’infrastruttura realizzata sinora comprende una rete LAN e una rete WAN. Ad ognuna è
assegnato un port switch virtuale che permette di creare la rete condivisa in VMWare dalle
macchine virtualizzate e da quelle esterne.
Abbiamo realizzato una nuova rete, una DMZ, nel quale abbiamo esposto un server di servizi
web. Abbiamo aggiunto al FW un' interfaccia ethernet e l' abbiamo chiamata DMZ, abbiamo aggiunto poi un virtual switch e gli abbiamo associato l'interfaccia appena creata.
\subsection{Sistema di monitoring utilizzato: Nagios}
Nagios è un'applicazione open source per il monitoraggio di computer e risorse di rete. La sua funzione base è quella di controllare nodi, reti e servizi specificati, avvertendo quando questi non garantiscono il loro servizio o quando ritornano attivi.In origine Nagios è stato sviluppato per Linux, ma può funzionare correttamente anche su altre varianti di Unix.
\subsubsection{Caratteristiche}
\begin{itemize}
    \item monitoraggio di servizi di rete (SMTP, POP3, HTTP, NNTP, ICMP, SNMP, FTP, SSH);
    \item monitoraggio delle risorse di sistema (carico del processore, uso dell'hard disk, log di sistema sulla maggior parte dei sistemi operativi, anche per Microsoft Windows);
    \item monitoraggio remoto supportato attraverso tunnel SSH o SSL;
    \item semplici plugin che permettono agli utenti di sviluppare facilmente nuovi controlli per i servizi in base alle proprie esigenze, usando bash, C++, Perl, Ruby, Python, PHP, C\#, ecc.;
    \item controlli paralleli sui servizi;
    \item capacità di definire gerarchie di nodi di rete usando nodi "parent", permettendo la distinzione tra nodi che sono down e nodi non raggiungibili;
    \item notifiche quando l'applicazione riscontra problemi o la loro risoluzione (via email, cercapersone, SMS, o con altri sistemi per mezzo di plugin aggiuntivi);
    \item capacità di definire "event handler", ovvero azioni automatiche che vengono attivate all'apparire o alla risoluzione di un problema;
    \item rotazione automatica dei file di log;
    \item supporto per l'implementazione di monitoring ridondante;
    \item interfaccia web opzionale per la visualizzazione dell'attuale stato, notifiche, storico dei problemi, file di log, ecc.
\end{itemize}
\subsection{Altri sistemi di monitoring}
\begin{figure}[H]
    \center
    \includegraphics[scale=0.45]{images/tabC.png}
    \caption{Sistemi di monitoring}\label{fig:1}
\end{figure}
\subsection{Punto 2-3-4}
\textcolor{red}{MANCANO QUESTI PUNTI DELL'ESERCITAZIONE 4}.
\section{Esercitazione 05}
Attivazione di una SAN e integrazione nel sistema sviluppato in laboratorio.
\subsection{Protocollo iSCSI}
In telecomunicazioni ed elettronica iSCSI (sta per "Internet SCSI") è un protocollo di comunicazione che permette di inviare comandi a dispositivi di memoria SCSI fisicamente collegati a server e/o altri dispositivi remoti (come ad esempio NAS o SAN). È un protocollo molto utilizzato in ambienti SAN poiché permette l'archiviazione dei dati su dischi virtuali, collegati attraverso la rete, dando l'illusione di disporre localmente di un disco fisico che invece si trova in realtà su un dispositivo di archiviazione remoto.
Il client utilizza quindi un driver, detto initiator, che consente di inviare all'host dove sono fisicamente ospitati i dischi, detto target, i comandi che consentono di leggere e scrivere il disco virtuale. L'initiator tipicamente si identifica tramite un codice alfanumerico, detto IQN (acronimo inglese di "iSCSI Qualified Name", in italiano "Nome Qualificato iSCSI") al quale può essere associata una policy di accesso basata sull'indirizzo IP mittente.
Il protocollo iSCSI supporta inoltre l'autenticazione tramite il protocollo CHAP.
\subsubsection{iSCSI vs Fibre Channel over Ethernet}
La differenza principale è che il protocollo Fibre Channel consente l'impacchettamento su TCP/IP, e attraverso l'infrastruttura di rete esistente rende possibile l'utilizzo di dispositivi a distanza.
Di seguito riportiamo i punti di forza delle due soluzioni:
\begin{itemize}
    \item iSCSI è sicuramente più adatto per le soluzioni di fascia bassa non richiedendo nessuna implementazione particolare della rete ethenet e operando su TCP/IP permette il suo utilizzo anche in ambito geografico. Esistono, inoltre, molte implementazioni software di server iSCSI e praticamente tutti i sistemi operativi attuale hanno un supporto per connessioni client iSCSI.
    \item FCoE è stato pensato per i CED in ambito locale dove la presenza di infrastrutture Fibre Channel è ampia. FCoE consente di utilizzare le stesse utility e funzionalità utilizzate su Fibre Channel oltre a fornire tutto il supporto per lo zoning. FCoE non ha bisogno di uno stack TCP/IP ed è quindi molto più efficiente di iSCSI.
\end{itemize}
\begin{figure}[H]
    \center
    \includegraphics[scale=0.4]{images/fig1.png}
    \caption{Sistemi di storage SAN}\label{fig:1}
\end{figure}
\subsection{Tabella comparativa dei sistemi di storage}
\textcolor{red}{MANCA QUESTO PUNTO DELL'ESERCITAZIONE 5}.

\end{document}
